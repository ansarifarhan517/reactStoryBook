{"ast":null,"code":"import { ROUTE_BATCH_LIMIT } from './../../constants/googleIntegration.constants';\n\nvar prepareCallStack = function prepareCallStack(waypoints) {\n  // prepare the proper batching for the waypoints in a multiple of 8's\n  // and prepare the intermediate data for the maintenance of actual google call fires\n  var pendingCallsStack = [];\n  var latlngHash = '';\n  var prevEndIndex = 0;\n\n  for (var i = 0; i < (waypoints === null || waypoints === void 0 ? void 0 : waypoints.length); i++) {\n    if (i && (i + 1) % ROUTE_BATCH_LIMIT === 0 || i === waypoints.length - 1) {\n      // if a multiple of 8 is encountered, then commit the current batch to path mapping, and restart the hash for next batch\n      // or if this is the last waypoint of the array, commit till here only\n      pendingCallsStack.push({\n        key: latlngHash,\n        // the unique key of this call\n        points: waypoints.slice(prevEndIndex, i + 1),\n        // the lat lngs in this call\n        path: [] // the actual path generated from google or otherwise, which will get plotted\n\n      });\n      latlngHash = '';\n      prevEndIndex = i;\n    }\n\n    latlngHash += waypoints[0] + waypoints[1];\n  }\n\n  return pendingCallsStack;\n};\n\nexport default prepareCallStack;","map":{"version":3,"sources":["/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/src/components/atoms/Map/utils/GoogleIntegration/prepareRouteCallStack.tsx"],"names":["ROUTE_BATCH_LIMIT","prepareCallStack","waypoints","pendingCallsStack","latlngHash","prevEndIndex","i","length","push","key","points","slice","path"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,+CAAlC;;AAEA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,SAAD,EAAsB;AAC7C;AACA;AAEA,MAAMC,iBAAiB,GAAG,EAA1B;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,YAAY,GAAG,CAAnB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAGJ,SAAH,aAAGA,SAAH,uBAAGA,SAAS,CAAEK,MAAd,CAAjB,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,QACGA,CAAC,IAAI,CAACA,CAAC,GAAG,CAAL,IAAUN,iBAAV,KAAgC,CAAtC,IACAM,CAAC,KAAKJ,SAAS,CAACK,MAAV,GAAmB,CAF3B,EAGE;AACA;AACA;AACAJ,MAAAA,iBAAiB,CAACK,IAAlB,CAAuB;AACrBC,QAAAA,GAAG,EAAEL,UADgB;AACJ;AACjBM,QAAAA,MAAM,EAAER,SAAS,CAACS,KAAV,CAAgBN,YAAhB,EAA8BC,CAAC,GAAG,CAAlC,CAFa;AAEyB;AAC9CM,QAAAA,IAAI,EAAE,EAHe,CAGL;;AAHK,OAAvB;AAMAR,MAAAA,UAAU,GAAG,EAAb;AACAC,MAAAA,YAAY,GAAGC,CAAf;AACD;;AAEDF,IAAAA,UAAU,IAAIF,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAtC;AACD;;AAED,SAAOC,iBAAP;AACD,CA7BD;;AA+BA,eAAeF,gBAAf","sourcesContent":["import { ROUTE_BATCH_LIMIT } from './../../constants/googleIntegration.constants'\n\nconst prepareCallStack = (waypoints: any[]) => {\n  // prepare the proper batching for the waypoints in a multiple of 8's\n  // and prepare the intermediate data for the maintenance of actual google call fires\n\n  const pendingCallsStack = []\n  let latlngHash = ''\n  let prevEndIndex = 0\n\n  for (let i = 0; i < waypoints?.length; i++) {\n    if (\n      (i && (i + 1) % ROUTE_BATCH_LIMIT === 0) ||\n      i === waypoints.length - 1\n    ) {\n      // if a multiple of 8 is encountered, then commit the current batch to path mapping, and restart the hash for next batch\n      // or if this is the last waypoint of the array, commit till here only\n      pendingCallsStack.push({\n        key: latlngHash, // the unique key of this call\n        points: waypoints.slice(prevEndIndex, i + 1), // the lat lngs in this call\n        path: [] as any // the actual path generated from google or otherwise, which will get plotted\n      })\n\n      latlngHash = ''\n      prevEndIndex = i\n    }\n\n    latlngHash += waypoints[0] + waypoints[1]\n  }\n\n  return pendingCallsStack\n}\n\nexport default prepareCallStack\n"]},"metadata":{},"sourceType":"module"}