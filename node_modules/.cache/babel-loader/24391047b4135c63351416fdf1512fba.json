{"ast":null,"code":"import _slicedToArray from \"/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _this = this,\n    _jsxFileName = \"/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/src/components/atoms/Map/layers/LeafletPolygonEditLayer.tsx\";\n\nimport LL from 'leaflet';\nimport React, { useEffect, useState } from 'react';\nimport { FeatureGroup, useLeaflet } from 'react-leaflet';\nimport { EditControl } from 'react-leaflet-draw';\nimport { intersect, multiPolygon } from 'turf';\nimport { StyledPopUp, PolygonToast } from '../StyledMap';\nimport Toast from '../../../molecules/Toast/Toast';\nimport EditPopUp from '../SubComponent/EditPopUp';\nimport ReactDOMServer from \"react-dom/server\";\n\nvar _ = require('lodash');\n\nvar checkIntersection = function checkIntersection(thisPolygon, polygonInfo) {\n  var polygonData = polygonInfo.data;\n  var positionCoordinateKey = polygonInfo.positionCoordinateKey; // in data which key gives coordinates\n\n  var intersectionFl = false; // all polygon layers\n\n  polygonData.forEach(function (polygonOption) {\n    var optionObj = polygonOption[positionCoordinateKey];\n    var optionArray = [];\n    optionObj.forEach(function (coordinate) {\n      optionArray.push(Object.values(coordinate));\n    }); // [[lat,long],[lat,long]]\n\n    var otherPolygon = multiPolygon([[_createTurfCompatiblePolygon(optionObj)]]);\n\n    try {\n      var intersection = intersect(thisPolygon, otherPolygon);\n\n      if (intersection) {\n        if (intersection.geometry.type === 'MultiPolygon') {\n          intersectionFl = true;\n        }\n      }\n    } catch (err) {\n      intersectionFl = true;\n    }\n  });\n  return intersectionFl;\n};\n\nvar _createTurfCompatiblePolygon = function _createTurfCompatiblePolygon(coordinates) {\n  var newValue = coordinates.map(function (eachCoordinate) {\n    return Object.values(eachCoordinate);\n  });\n  return newValue;\n};\n\nvar LeafletPolygonEditLayer = function LeafletPolygonEditLayer(_ref) {\n  var editLayer = _ref.editLayer,\n      createPermission = _ref.createPermission,\n      orinalCoordinatesKey = _ref.orinalCoordinatesKey,\n      polygon = _ref.polygon,\n      editPopUpComponent = _ref.editPopUpComponent,\n      onChange = _ref.onChange;\n  var featureGroupRef = React.useRef();\n  var editRef = React.useRef();\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      removedLayer = _useState2[0],\n      setRemovedLayer = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      showToast = _useState4[0],\n      setShowToast = _useState4[1];\n\n  var colorKey = polygon.colorKey; // the color of polygon\n\n  var styleKeys = polygon === null || polygon === void 0 ? void 0 : polygon.styleKey; // circle style\n\n  var renderer = LL.canvas({\n    padding: 0.5\n  }); // adding renderer if canvasRenderer present in polygon\n\n  var _useLeaflet = useLeaflet(),\n      map = _useLeaflet.map;\n\n  var obj = document.getElementById('closePopupBtn');\n\n  if (obj !== null) {\n    obj.onclick = function () {\n      map === null || map === void 0 ? void 0 : map.closePopup();\n    };\n  }\n\n  useEffect(function () {\n    renderPloyLayer();\n  }, []);\n\n  var renderPloyLayer = function renderPloyLayer() {\n    // populate the leaflet FeatureGroup with the geoJson layers\n    if ((featureGroupRef === null || featureGroupRef === void 0 ? void 0 : featureGroupRef.current) && orinalCoordinatesKey) {\n      // eslint-disable-next-line\n      var leafletFG = featureGroupRef === null || featureGroupRef === void 0 ? void 0 : featureGroupRef.current;\n      /* eslint-disable-line no-alert */\n\n      var leafletElement = leafletFG.leafletElement;\n      var geoJsonData = editLayer === null || editLayer === void 0 ? void 0 : editLayer.data; // suppose geoJsonData [{bhiwandi},{Dadar}]\n\n      var coordinates = geoJsonData.map(function (option) {\n        var optionObj = option[orinalCoordinatesKey];\n        var optionArray = [];\n        optionObj.forEach(function (coordinate) {\n          optionArray.push(Object.values(coordinate));\n        }); // [[lat,long],[lat,long]]\n\n        return optionArray;\n      }); // [{latitude:'',longitude:''},{latitude:'',longitude:''}]\n\n      var polyLayers = [];\n      coordinates === null || coordinates === void 0 ? void 0 : coordinates.forEach(function (option) {\n        polyLayers.push(LL.polygon(option, {\n          interactive: true,\n          lineJoin: 'round',\n          lineCap: 'round',\n          fill: true,\n          stroke: true,\n          fillColor: (styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.fillColor) && option[styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.fillColor] ? option[styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.fillColor] : '',\n          fillOpacity: (styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.fillOpacity) && option[styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.fillOpacity] ? option[styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.fillOpacity] : 0.2,\n          opacity: 1,\n          smoothFactor: (styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.smoothFactor) && option[styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.smoothFactor] ? option[styleKeys === null || styleKeys === void 0 ? void 0 : styleKeys.smoothFactor] : 1,\n          renderer: (option === null || option === void 0 ? void 0 : option.canvasRenderer) ? renderer : null,\n          color: option[colorKey] ? option[colorKey] : '#3388ff'\n        }));\n      });\n\n      for (var _i = 0, _polyLayers = polyLayers; _i < _polyLayers.length; _i++) {\n        var _layer$editing;\n\n        var layer = _polyLayers[_i];\n        // add polygon layer to featuregroup\n        leafletElement.addLayer(layer); // make poly layer editable on load\n\n        layer === null || layer === void 0 ? void 0 : (_layer$editing = layer.editing) === null || _layer$editing === void 0 ? void 0 : _layer$editing.enable();\n      }\n    }\n  }; // when creating new layer, keep it editable and remove previous all layer, only one edited layer creation is permitted\n\n\n  var _onCreated = function _onCreated(e) {\n    var _drawnItems$latestCre;\n\n    var layer = e.layer;\n    layer.bindPopup(ReactDOMServer.renderToString( /*#__PURE__*/React.createElement(EditPopUp, {\n      onClick: function onClick() {\n        map === null || map === void 0 ? void 0 : map.closePopup();\n      },\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 51\n      }\n    }))).openPopup(); // all layer on featuregroup\n\n    var drawnItems = featureGroupRef.current.leafletElement._layers; // all editable layer with newly created layer on last index on array\n\n    var drawnItemsValue = Object.keys(drawnItems);\n    var latestCreatedItem = drawnItemsValue[drawnItemsValue.length - 1]; // only created layer will remain,lat lang of that layer\n\n    var newLatLng = (_drawnItems$latestCre = drawnItems[latestCreatedItem]) === null || _drawnItems$latestCre === void 0 ? void 0 : _drawnItems$latestCre._latlngs[0];\n\n    var polyObjTurfCompatible = _createTurfCompatiblePolygon(newLatLng); // user created below polygon\n\n\n    var thisPolygon = multiPolygon([[polyObjTurfCompatible]]);\n    var isInterSection = checkIntersection(thisPolygon, polygon);\n\n    if (drawnItemsValue.length > 0) {\n      drawnItemsValue.forEach(function (layerid) {\n        var layer = drawnItems[layerid]; // if intersection then remove last latest layer and keep old data\n\n        if (isInterSection) {\n          if (latestCreatedItem === layerid) {\n            // remove latest layer and add old layers\n            featureGroupRef.current.leafletElement.removeLayer(layer);\n            removedLayer && removedLayer.forEach(function (element) {\n              featureGroupRef.current.leafletElement.addLayer(element);\n            });\n            setShowToast(true);\n            setTimeout(function () {\n              setShowToast(false);\n            }, 3000);\n          }\n        } else {\n          // keep last, latest area,remove remaining, (we are allowing only one area to create)\n          if (latestCreatedItem === layerid) {\n            var _layer$editing2;\n\n            layer === null || layer === void 0 ? void 0 : (_layer$editing2 = layer.editing) === null || _layer$editing2 === void 0 ? void 0 : _layer$editing2.enable();\n            editRef.current.leafletElement.recentlyEdittedLatLng = _.cloneDeep(layer._latlngs);\n            return;\n          }\n\n          featureGroupRef.current.leafletElement.removeLayer(layer);\n        }\n      });\n    }\n\n    if (!isInterSection) {\n      // send out to save in the form\n      onChange({\n        coordinates: [],\n        originalCoordinates: newLatLng,\n        isChanged: false\n      });\n    }\n  }; // when edited layer while creation, vertex gets changes\n\n\n  var _onDrawVertex = function _onDrawVertex(e) {\n    var originalLatLng = [];\n    var newLatLng = [];\n    var layers = e.layers;\n\n    if (Object.keys(layers === null || layers === void 0 ? void 0 : layers._layers).length > 2) {\n      editRef.current.leafletElement._toolbars.draw._modes.polygon.handler.completeShape();\n    }\n\n    layers === null || layers === void 0 ? void 0 : layers.eachLayer(function (_layer) {\n      var _layer$_origLatLng, _layer$_origLatLng2, _layer$_latlng, _layer$_latlng2;\n\n      originalLatLng.push([_layer === null || _layer === void 0 ? void 0 : (_layer$_origLatLng = _layer._origLatLng) === null || _layer$_origLatLng === void 0 ? void 0 : _layer$_origLatLng.lat, _layer === null || _layer === void 0 ? void 0 : (_layer$_origLatLng2 = _layer._origLatLng) === null || _layer$_origLatLng2 === void 0 ? void 0 : _layer$_origLatLng2.lng]);\n      newLatLng.push(Object.values([_layer === null || _layer === void 0 ? void 0 : (_layer$_latlng = _layer._latlng) === null || _layer$_latlng === void 0 ? void 0 : _layer$_latlng.lat, _layer === null || _layer === void 0 ? void 0 : (_layer$_latlng2 = _layer._latlng) === null || _layer$_latlng2 === void 0 ? void 0 : _layer$_latlng2.lng]));\n    });\n    onChange({\n      coordinates: newLatLng,\n      originalCoordinates: newLatLng,\n      isChanged: true\n    });\n  }; // when user clicks on create layer\n\n\n  var _onDrawStart = function _onDrawStart(_e) {\n    // all layer on featuregroup\n    var drawnItems = featureGroupRef.current.leafletElement._layers; // all editable layer with newly created layer on last index on array\n\n    var drawnItemsValue = Object.keys(drawnItems);\n    var removedLayer = [];\n\n    if (drawnItemsValue.length > 1) {\n      drawnItemsValue.forEach(function (layerid) {\n        // remove all existing edited layer if start creating new\n        var layer = drawnItems[layerid];\n        removedLayer.push(layer);\n        featureGroupRef.current.leafletElement.removeLayer(layer);\n      });\n    } // ret removed layer list to restore if intersection\n\n\n    setRemovedLayer(removedLayer);\n  }; // when in edited mode,change in verted captured here\n\n\n  var onEditVertex = function onEditVertex(e) {\n    var _editRef$current$leaf;\n\n    var originalLatLng = [];\n    var newLatLng = [];\n    var target = e.target;\n    target.eachLayer(function (_layer) {\n      if (Object.prototype.hasOwnProperty.call(_layer, 'edited')) {\n        if (_layer.editing.latlngs[0]) {\n          var _layer$editing$latlng;\n\n          (_layer$editing$latlng = _layer.editing.latlngs[0][0]) === null || _layer$editing$latlng === void 0 ? void 0 : _layer$editing$latlng.forEach(function (latLng) {\n            newLatLng.push([latLng.lat, latLng.lng]);\n          });\n        }\n      }\n    });\n    console.log(originalLatLng, 'originalLatLng and newLatLng', newLatLng);\n    var thisPolygon = multiPolygon([[newLatLng]]);\n    var isInterSection = checkIntersection(thisPolygon, polygon);\n    var drawnItems = featureGroupRef.current.leafletElement._layers;\n    var drawnItemsValue = Object.keys(drawnItems);\n    var latestCreatedItem = drawnItemsValue[drawnItemsValue.length - 1];\n    drawnItemsValue.forEach(function (layerid) {\n      var layer = drawnItems[layerid]; // if intersection then remove last latest layer and keep old data\n\n      if (isInterSection) {\n        if (latestCreatedItem === layerid) {\n          setShowToast(true);\n          setTimeout(function () {\n            setShowToast(false);\n          }, 3000);\n        }\n      } else {\n        if (latestCreatedItem === layerid) {\n          editRef.current.leafletElement.recentlyEdittedLatLng = _.cloneDeep(layer._latlngs);\n          return;\n        }\n      }\n    });\n    onChange({\n      coordinates: newLatLng,\n      originalCoordinates: newLatLng,\n      isChanged: true,\n      isIntersection: !(JSON.stringify(editRef.current.leafletElement.recentlyEdittedLatLng) == JSON.stringify(e.poly._latlngs)),\n      previousCoordinates: (_editRef$current$leaf = editRef.current.leafletElement.recentlyEdittedLatLng) === null || _editRef$current$leaf === void 0 ? void 0 : _editRef$current$leaf[0]\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(FeatureGroup, {\n    ref: featureGroupRef,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 296,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(EditControl, {\n    ref: editRef,\n    position: \"bottomright\",\n    onCreated: _onCreated,\n    onDrawVertex: _onDrawVertex,\n    onDrawStart: _onDrawStart,\n    onEditVertex: onEditVertex,\n    draw: createPermission ? {\n      rectangle: false,\n      polyline: false,\n      circle: false,\n      marker: false,\n      circlemarker: false,\n      polygon: {\n        allowIntersection: false,\n        showArea: true,\n        clickable: true\n      }\n    } : false,\n    edit: {\n      remove: false,\n      allowIntersection: false,\n      edit: false,\n      toolbar: false\n    },\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(StyledPopUp, {\n    keepInView: true,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 327,\n      columnNumber: 7\n    }\n  }, editPopUpComponent && editPopUpComponent({\n    map: map\n  })), showToast && /*#__PURE__*/React.createElement(PolygonToast, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 331,\n      columnNumber: 6\n    }\n  }, /*#__PURE__*/React.createElement(Toast, {\n    iconVariant: \"warning\",\n    removeButton: false,\n    remove: function remove() {},\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 332,\n      columnNumber: 6\n    }\n  }, \"Overlaps not allowed!!\")));\n};\n\nexport default LeafletPolygonEditLayer;","map":{"version":3,"sources":["/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/src/components/atoms/Map/layers/LeafletPolygonEditLayer.tsx"],"names":["LL","React","useEffect","useState","FeatureGroup","useLeaflet","EditControl","intersect","multiPolygon","StyledPopUp","PolygonToast","Toast","EditPopUp","ReactDOMServer","_","require","checkIntersection","thisPolygon","polygonInfo","polygonData","data","positionCoordinateKey","intersectionFl","forEach","polygonOption","optionObj","optionArray","coordinate","push","Object","values","otherPolygon","_createTurfCompatiblePolygon","intersection","geometry","type","err","coordinates","newValue","map","eachCoordinate","LeafletPolygonEditLayer","editLayer","createPermission","orinalCoordinatesKey","polygon","editPopUpComponent","onChange","featureGroupRef","useRef","editRef","removedLayer","setRemovedLayer","showToast","setShowToast","colorKey","styleKeys","styleKey","renderer","canvas","padding","obj","document","getElementById","onclick","closePopup","renderPloyLayer","current","leafletFG","leafletElement","geoJsonData","option","polyLayers","interactive","lineJoin","lineCap","fill","stroke","fillColor","fillOpacity","opacity","smoothFactor","canvasRenderer","color","layer","addLayer","editing","enable","_onCreated","e","bindPopup","renderToString","openPopup","drawnItems","_layers","drawnItemsValue","keys","latestCreatedItem","length","newLatLng","_latlngs","polyObjTurfCompatible","isInterSection","layerid","removeLayer","element","setTimeout","recentlyEdittedLatLng","cloneDeep","originalCoordinates","isChanged","_onDrawVertex","originalLatLng","layers","_toolbars","draw","_modes","handler","completeShape","eachLayer","_layer","_origLatLng","lat","lng","_latlng","_onDrawStart","_e","onEditVertex","target","prototype","hasOwnProperty","call","latlngs","latLng","console","log","isIntersection","JSON","stringify","poly","previousCoordinates","rectangle","polyline","circle","marker","circlemarker","allowIntersection","showArea","clickable","remove","edit","toolbar"],"mappings":"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","sourcesContent":["import LL from 'leaflet'\nimport React, { useEffect, useState } from 'react'\nimport { FeatureGroup, useLeaflet } from 'react-leaflet'\nimport { EditControl } from 'react-leaflet-draw'\nimport { intersect, multiPolygon } from 'turf'\nimport { StyledPopUp, PolygonToast } from '../StyledMap'\nimport Toast from '../../../molecules/Toast/Toast'\nimport EditPopUp from '../SubComponent/EditPopUp'\nimport ReactDOMServer from \"react-dom/server\";\nconst _ = require('lodash');\ninterface ILeafletPolygonEditLayer {\n  editLayer: any\n  createPermission: boolean\n  onChange: (changedObject: IChangedObject) => void\n  orinalCoordinatesKey: string | undefined\n  createShape: boolean\n  setCreateShape: (createShape: boolean) => void\n  editPopUpComponent: ({ map }: any) => React.ReactNode\n  polygon: any\n}\ninterface IChangedObject {\n  coordinates: any[]\n  originalCoordinates: any[]\n  isChanged: boolean,\n  isIntersection?:boolean,\n  previousCoordinates?:any[]\n}\n\nconst checkIntersection = (thisPolygon: any, polygonInfo: any) => {\n  const polygonData = polygonInfo.data\n  const positionCoordinateKey = polygonInfo.positionCoordinateKey // in data which key gives coordinates\n  let intersectionFl = false\n  // all polygon layers\n  polygonData.forEach((polygonOption: any) => {\n    const optionObj = polygonOption[positionCoordinateKey]\n    const optionArray: any[] = []\n    optionObj.forEach((coordinate: any) => {\n      optionArray.push(Object.values(coordinate))\n    }) // [[lat,long],[lat,long]]\n    var otherPolygon = multiPolygon([[_createTurfCompatiblePolygon(optionObj)]])\n    try {\n      var intersection = intersect(thisPolygon, otherPolygon)\n      if (intersection) {\n        if (intersection.geometry.type === 'MultiPolygon') {\n          intersectionFl = true\n        }\n      }\n    } catch (err) {\n      intersectionFl = true\n    }\n  })\n  return intersectionFl\n}\n\nconst _createTurfCompatiblePolygon = (coordinates: any) => {\n  const newValue = coordinates.map((eachCoordinate: any) =>\n    Object.values(eachCoordinate)\n  )\n\n  return newValue\n}\nconst LeafletPolygonEditLayer = ({\n  editLayer,\n  createPermission,\n  orinalCoordinatesKey,\n  polygon,\n  // createShape,\n  // setCreateShape,\n  editPopUpComponent,\n  onChange\n}: ILeafletPolygonEditLayer) => {\n  const featureGroupRef: any = React.useRef()\n  const editRef: any = React.useRef()\n  const [removedLayer, setRemovedLayer] = useState<any[] | null>(null)\n  const [showToast, setShowToast] = useState<boolean>(false)\n  const colorKey = polygon.colorKey // the color of polygon\n  const styleKeys = polygon?.styleKey // circle style\n\n  const renderer: any = LL.canvas({ padding: 0.5 }) // adding renderer if canvasRenderer present in polygon\n\n\n  const { map } = useLeaflet()\n  const obj = document.getElementById('closePopupBtn');\n  if(obj !== null){\n    obj.onclick=()=>{\n      map?.closePopup();\n    }\n  }\n\n  useEffect(() => {\n    renderPloyLayer()\n  }, [])\n  const renderPloyLayer = () => {\n    // populate the leaflet FeatureGroup with the geoJson layers\n\n    if (featureGroupRef?.current && orinalCoordinatesKey) {\n      // eslint-disable-next-line\n      const leafletFG =\n        featureGroupRef?.current /* eslint-disable-line no-alert */\n      const { leafletElement } = leafletFG\n      const geoJsonData = editLayer?.data\n\n      // suppose geoJsonData [{bhiwandi},{Dadar}]\n      const coordinates = geoJsonData.map((option: any) => {\n        const optionObj = option[orinalCoordinatesKey]\n        const optionArray: any[] = []\n        optionObj.forEach((coordinate: any) => {\n          optionArray.push(Object.values(coordinate))\n        }) // [[lat,long],[lat,long]]\n\n        return optionArray\n      }) // [{latitude:'',longitude:''},{latitude:'',longitude:''}]\n\n      const polyLayers: any[] = []\n      coordinates?.forEach((option: any) => {\n        polyLayers.push(\n          LL.polygon(option, {\n            interactive: true,\n            lineJoin: 'round',\n            lineCap: 'round',\n            fill: true,\n            stroke: true,\n            fillColor:\n              styleKeys?.fillColor && option[styleKeys?.fillColor]\n                ? option[styleKeys?.fillColor]\n                : '',\n            fillOpacity:\n              styleKeys?.fillOpacity && option[styleKeys?.fillOpacity]\n                ? option[styleKeys?.fillOpacity]\n                : 0.2,\n            opacity:1, \n            smoothFactor:\n              styleKeys?.smoothFactor && option[styleKeys?.smoothFactor]\n                ? option[styleKeys?.smoothFactor]\n                : 1,\n            renderer: option?.canvasRenderer ? renderer : null,\n            color: option[colorKey] ? option[colorKey] : '#3388ff'\n          })\n        )\n      })\n\n      for (const layer of polyLayers) {\n        // add polygon layer to featuregroup\n        leafletElement.addLayer(layer)\n\n        // make poly layer editable on load\n        layer?.editing?.enable()\n      }\n    }\n  }\n\n  // when creating new layer, keep it editable and remove previous all layer, only one edited layer creation is permitted\n  const _onCreated = (e: any) => {\n    const layer = e.layer\n    layer.bindPopup(ReactDOMServer.renderToString(<EditPopUp onClick={() => { map?.closePopup()}}/>)).openPopup();\n    // all layer on featuregroup\n    const drawnItems = featureGroupRef.current.leafletElement._layers\n    // all editable layer with newly created layer on last index on array\n    const drawnItemsValue = Object.keys(drawnItems)\n    const latestCreatedItem = drawnItemsValue[drawnItemsValue.length - 1]\n    // only created layer will remain,lat lang of that layer\n    const newLatLng = drawnItems[latestCreatedItem]?._latlngs[0]\n    const polyObjTurfCompatible = _createTurfCompatiblePolygon(newLatLng)\n    // user created below polygon\n    const thisPolygon = multiPolygon([[polyObjTurfCompatible]])\n    const isInterSection = checkIntersection(thisPolygon, polygon)\n\n    if (drawnItemsValue.length > 0) {\n      drawnItemsValue.forEach((layerid) => {\n        const layer = drawnItems[layerid]\n        // if intersection then remove last latest layer and keep old data\n        if (isInterSection) {\n          if (latestCreatedItem === layerid) {\n            // remove latest layer and add old layers\n            featureGroupRef.current.leafletElement.removeLayer(layer)\n            removedLayer &&\n              removedLayer.forEach((element) => {\n                featureGroupRef.current.leafletElement.addLayer(element)\n              })\n              setShowToast(true);\n              setTimeout(()=>{\n              setShowToast(false);\n            }, 3000)\n          }\n        } else {\n          // keep last, latest area,remove remaining, (we are allowing only one area to create)\n          if (latestCreatedItem === layerid) {\n            layer?.editing?.enable()\n            editRef.current.leafletElement.recentlyEdittedLatLng = _.cloneDeep(layer._latlngs)\n            return\n          }\n          featureGroupRef.current.leafletElement.removeLayer(layer)\n        }\n      })\n    }\n    if (!isInterSection) {\n      // send out to save in the form\n      onChange({\n        coordinates: [],\n        originalCoordinates: newLatLng,\n        isChanged: false\n      })\n    }\n  }\n\n  // when edited layer while creation, vertex gets changes\n  const _onDrawVertex = (e: any) => {\n    const originalLatLng: any[] = []\n    const newLatLng: any[] = []\n    const { layers }: any = e\n    if (Object.keys(layers?._layers).length > 2) {\n      editRef.current.leafletElement._toolbars.draw._modes.polygon.handler.completeShape()\n    }\n    layers?.eachLayer((_layer: any) => {\n      originalLatLng.push([_layer?._origLatLng?.lat, _layer?._origLatLng?.lng])\n      newLatLng.push(\n        Object.values([_layer?._latlng?.lat, _layer?._latlng?.lng])\n      )\n    })\n    onChange({\n      coordinates: newLatLng,\n      originalCoordinates: newLatLng,\n      isChanged: true\n    })\n  }\n\n  // when user clicks on create layer\n  const _onDrawStart = (_e: any) => {\n    // all layer on featuregroup\n    const drawnItems = featureGroupRef.current.leafletElement._layers\n    // all editable layer with newly created layer on last index on array\n    const drawnItemsValue = Object.keys(drawnItems)\n    const removedLayer: any[] = []\n\n    if (drawnItemsValue.length > 1) {\n      drawnItemsValue.forEach((layerid) => {\n        // remove all existing edited layer if start creating new\n        const layer = drawnItems[layerid]\n        removedLayer.push(layer)\n        featureGroupRef.current.leafletElement.removeLayer(layer)\n      })\n    }\n    // ret removed layer list to restore if intersection\n    setRemovedLayer(removedLayer)\n  }\n\n  // when in edited mode,change in verted captured here\n  const onEditVertex = (e: any) => {\n    const originalLatLng: any[] = []\n    const newLatLng: any[] = []\n    const {target }: any = e\n    target.eachLayer((_layer: any) => {\n      if (Object.prototype.hasOwnProperty.call(_layer, 'edited')) {\n        if (_layer.editing.latlngs[0]) {\n          _layer.editing.latlngs[0][0]?.forEach((latLng: any) => {\n            newLatLng.push([latLng.lat, latLng.lng])\n          })\n        }\n      }\n    })\n\n    console.log(originalLatLng, 'originalLatLng and newLatLng', newLatLng)\n    const thisPolygon = multiPolygon([[newLatLng]])\n    const isInterSection = checkIntersection(thisPolygon, polygon)\n    const drawnItems = featureGroupRef.current.leafletElement._layers\n    const drawnItemsValue = Object.keys(drawnItems)\n    const latestCreatedItem = drawnItemsValue[drawnItemsValue.length - 1]\n    drawnItemsValue.forEach((layerid) => {\n      const layer = drawnItems[layerid]\n      // if intersection then remove last latest layer and keep old data\n      if (isInterSection) {\n        if (latestCreatedItem === layerid) {\n          setShowToast(true);  \n           setTimeout(()=>{\n            setShowToast(false);\n          }, 3000)\n        }\n      } else {\n        if (latestCreatedItem === layerid) { \n          editRef.current.leafletElement.recentlyEdittedLatLng = _.cloneDeep(layer._latlngs)\n          return\n        }\n      }\n    })\n\n    onChange({\n      coordinates: newLatLng,\n      originalCoordinates: newLatLng,\n      isChanged: true,\n      isIntersection:!(JSON.stringify(editRef.current.leafletElement.recentlyEdittedLatLng) == JSON.stringify(e.poly._latlngs)),\n      previousCoordinates: editRef.current.leafletElement.recentlyEdittedLatLng?.[0]\n    })\n  }\n\n  return (\n    <FeatureGroup ref={featureGroupRef as any}>\n      <EditControl\n        ref={editRef as any}\n        position='bottomright'\n        onCreated={_onCreated}\n        onDrawVertex={_onDrawVertex}\n        onDrawStart={_onDrawStart}\n        onEditVertex={onEditVertex}\n        draw={\n          createPermission\n            ? {\n                rectangle: false,\n                polyline: false,\n                circle: false,\n                marker: false,\n                circlemarker: false,\n                polygon: {\n                  allowIntersection: false,\n                  showArea: true,\n                  clickable: true\n                }\n              }\n            : false\n        }\n        edit={{\n          remove: false,\n          allowIntersection: false,\n          edit: false,\n          toolbar: false\n        }}\n      />\n      <StyledPopUp keepInView>\n        {editPopUpComponent && editPopUpComponent({ map })}\n      </StyledPopUp>\n      {showToast && \n     <PolygonToast>\n     <Toast  iconVariant='warning'\n          removeButton={false}\n          remove={()=> {}}>\n           Overlaps not allowed!!\n      </Toast>\n      </PolygonToast>\n      }\n    </FeatureGroup>\n  )\n}\n\nexport default LeafletPolygonEditLayer\n"]},"metadata":{},"sourceType":"module"}