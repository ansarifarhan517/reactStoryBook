{"ast":null,"code":"import _regeneratorRuntime from \"/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { RECURSIVE_CALL_ATTEMPT_LIMIT } from './../../constants/googleIntegration.constants';\nimport { googleLatLng, googleRoutesWaypoints } from './googleLatLngConversion';\nimport decodePolyline from './decodePolyline';\n\nvar googleRouteCall = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props, waypoints) {\n    var iteration,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            iteration = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 0;\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var decodedPolylineArray = [];\n\n              if (!iteration || iteration < RECURSIVE_CALL_ATTEMPT_LIMIT) {\n                // if the iteration is within the recursie limit, fire the call,\n                // else simply plot original waypoints as the aerial path\n                var google = props.google;\n                var directionsService = new google.maps.DirectionsService();\n                var directionsRequest = {\n                  origin: googleLatLng(waypoints[0]),\n                  destination: googleLatLng(waypoints[waypoints.length - 1]),\n                  waypoints: googleRoutesWaypoints(waypoints),\n                  travelMode: google.maps.TravelMode.DRIVING,\n                  unitSystem: google.maps.UnitSystem.METRIC\n                };\n                directionsService.route(directionsRequest, function (response, status) {\n                  if (status === google.maps.DirectionsStatus.OVER_QUERY_LIMIT) {\n                    setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.next = 2;\n                              return googleRouteCall(props, waypoints, iteration++);\n\n                            case 2:\n                              decodedPolylineArray = _context.sent;\n\n                            case 3:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    })), 2000);\n                  } else if (status === google.maps.DirectionsStatus.OK) {\n                    var _response$routes, _response$routes$;\n\n                    if (response === null || response === void 0 ? void 0 : (_response$routes = response.routes) === null || _response$routes === void 0 ? void 0 : (_response$routes$ = _response$routes['0']) === null || _response$routes$ === void 0 ? void 0 : _response$routes$.legs) {\n                      response.routes['0'].legs.forEach(function (leg) {\n                        if (leg && leg.steps) {\n                          leg.steps.forEach(function (step) {\n                            // add the encoded polyline to the string\n                            decodedPolylineArray.push(decodePolyline(step.polyline.points.toString()));\n                          });\n                        }\n                      });\n                    }\n\n                    resolve(decodedPolylineArray);\n                  } else {\n                    reject(decodedPolylineArray);\n                  }\n                });\n              } else {\n                // iterations over, simply plot original waypoints as the aerial path\n                decodedPolylineArray = waypoints;\n                reject(decodedPolylineArray);\n              }\n            }));\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function googleRouteCall(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport default googleRouteCall;","map":{"version":3,"sources":["/Users/farhanansari/Desktop/CODE/PrxProject/untitled folder/reactStoryBook/src/components/atoms/Map/utils/GoogleIntegration/googleRouteCall.tsx"],"names":["RECURSIVE_CALL_ATTEMPT_LIMIT","googleLatLng","googleRoutesWaypoints","decodePolyline","googleRouteCall","props","waypoints","iteration","Promise","resolve","reject","decodedPolylineArray","google","directionsService","maps","DirectionsService","directionsRequest","origin","destination","length","travelMode","TravelMode","DRIVING","unitSystem","UnitSystem","METRIC","route","response","status","DirectionsStatus","OVER_QUERY_LIMIT","setTimeout","OK","routes","legs","forEach","leg","steps","step","push","polyline","points","toString"],"mappings":"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","sourcesContent":["import { RECURSIVE_CALL_ATTEMPT_LIMIT } from './../../constants/googleIntegration.constants'\nimport { googleLatLng, googleRoutesWaypoints } from './googleLatLngConversion'\nimport decodePolyline from './decodePolyline'\n\nconst googleRouteCall = async (props: any, waypoints: any[], iteration = 0) => {\n  return new Promise<any[]>((resolve, reject) => {\n    let decodedPolylineArray: any[] = []\n\n    if (!iteration || iteration < RECURSIVE_CALL_ATTEMPT_LIMIT) {\n      // if the iteration is within the recursie limit, fire the call,\n      // else simply plot original waypoints as the aerial path\n\n      const google = props.google\n      const directionsService = new google.maps.DirectionsService()\n      const directionsRequest = {\n        origin: googleLatLng(waypoints[0]),\n        destination: googleLatLng(waypoints[waypoints.length - 1]),\n        waypoints: googleRoutesWaypoints(waypoints),\n        travelMode: google.maps.TravelMode.DRIVING,\n        unitSystem: google.maps.UnitSystem.METRIC\n      }\n\n      directionsService.route(directionsRequest, function (\n        response: any,\n        status: string\n      ) {\n        if (status === google.maps.DirectionsStatus.OVER_QUERY_LIMIT) {\n          setTimeout(async () => {\n            // over query limit, fire the same call after 2 seconds\n            decodedPolylineArray = await googleRouteCall(\n              props,\n              waypoints,\n              iteration++\n            )\n          }, 2000)\n        } else if (status === google.maps.DirectionsStatus.OK) {\n          if (response?.routes?.['0']?.legs) {\n            response.routes['0'].legs.forEach(function (leg: any) {\n              if (leg && leg.steps) {\n                leg.steps.forEach(function (step: any) {\n                  // add the encoded polyline to the string\n                  decodedPolylineArray.push(\n                    decodePolyline(step.polyline.points.toString())\n                  )\n                })\n              }\n            })\n          }\n          resolve(decodedPolylineArray)\n        } else {\n          reject(decodedPolylineArray)\n        }\n      })\n    } else {\n      // iterations over, simply plot original waypoints as the aerial path\n      decodedPolylineArray = waypoints\n      reject(decodedPolylineArray)\n    }\n  })\n}\n\nexport default googleRouteCall\n"]},"metadata":{},"sourceType":"module"}